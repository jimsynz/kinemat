defmodule Kinemat.URDF.Parser do
  alias Kinemat.{Coordinates, Frame, Geometry, Orientations, Robot}
  import Kinemat.URDF.XmlHelpers
  require Logger

  @moduledoc """
  This module implements URDF parsing using the XML nodes generated by Erlang's
  `:xmerl` application.
  """

  @doc """
  Attempts to parse an `:xmerl` `xmlElement` record as a URDF document.
  """
  @spec parse(Kinemat.URDF.XmlHelpers.xmlElement()) :: {:ok, Robot.t()} | {:error, any}
  def parse(node) when is_element(node), do: parse(node, nil)

  defp parse(node, state) when is_element(node) do
    with {:ok, name} <- get_name(node),
         do: parse(name, node, state)
  end

  defp parse(node, state) when is_text(node), do: {:ok, state}

  defp parse(:robot, node, nil) when is_element(node) do
    with {:ok, name} <- get_attribute_value(node, :name),
         robot <- Robot.init(name),
         {:ok, children} <- get_children(node) do
      Enum.reduce_while(children, {:ok, robot}, fn node, {:ok, robot} ->
        case parse(node, robot) do
          {:ok, robot} -> {:cont, {:ok, robot}}
          {:error, reason} -> {:halt, {:error, reason}}
        end
      end)
    end
  end

  defp parse(:link, node, %Robot{} = robot) do
    with {:ok, name} <- get_attribute_value(node, :name),
         link <- Robot.Link.init(name),
         {:ok, children} <- get_children(node),
         {:ok, link} <- reduce_oks(children, link, &parse(&1, &2)),
         do: {:ok, Robot.add_link(robot, link)}
  end

  defp parse(:joint, node, %Robot{} = robot) do
    with {:ok, name} <- get_attribute_value(node, :name),
         {:ok, type} <- get_attribute_value(node, :type),
         joint <- Robot.Joint.init(name, type),
         {:ok, children} <- get_children(node),
         {:ok, joint} <- reduce_oks(children, joint, &parse(&1, &2)),
         do: {:ok, Robot.add_joint(robot, joint)}
  end

  defp parse(:material, node, %Robot{} = robot) do
    with {:ok, name} <- get_attribute_value(node, :name),
         material <- Robot.Material.init(name),
         {:ok, children} <- get_children(node),
         {:ok, material} <- reduce_oks(children, material, &parse(&1, &2)),
         do: {:ok, Robot.add_material(robot, material)}
  end

  defp parse(:color, node, %Robot.Material{} = material) do
    [r, g, b, a] = extract_floats(node, :rgba, [0, 0, 0, 0])
    {:ok, Robot.Material.colour(material, Robot.Colour.init(r, g, b, a))}
  end

  defp parse(:parent, node, %Robot.Joint{} = joint) do
    with {:ok, name} <- get_attribute_value(node, :link),
         do: {:ok, Robot.Joint.parent_name(joint, name)}
  end

  defp parse(:child, node, %Robot.Joint{} = joint) do
    with {:ok, name} <- get_attribute_value(node, :link),
         do: {:ok, Robot.Joint.child_name(joint, name)}
  end

  defp parse(:visual, node, %Robot.Link{} = link) do
    with {:ok, children} <- get_children(node),
         visual <- Robot.Visual.init(),
         {:ok, visual} <- reduce_oks(children, visual, &parse(&1, &2)),
         do: {:ok, Robot.Link.visual(link, visual)}
  end

  defp parse(:geometry, node, geometric) do
    with {:ok, children} <- get_children(node),
         {:ok, geometric} <- reduce_oks(children, geometric, &parse(&1, &2)),
         do: {:ok, geometric}
  end

  defp parse(:cylinder, node, geometric) do
    with [length] <- extract_floats(node, :length, [0]),
         [radius] <- extract_floats(node, :radius, [0]),
         cylinder <- Geometry.Cylinder.init(length, radius),
         do: {:ok, Robot.Geometric.set(geometric, cylinder)}
  end

  defp parse(:box, node, geometric) do
    with [x, y, z] <- extract_floats(node, :size, [0, 0, 0]),
         box <- Geometry.Box.init(x, y, z),
         do: {:ok, Robot.Geometric.set(geometric, box)}
  end

  defp parse(:sphere, node, geometric) do
    with [radius] <- extract_floats(node, :radius, [0]),
         sphere <- Geometry.Sphere.init(radius),
         do: {:ok, Robot.Geometric.set(geometric, sphere)}
  end

  defp parse(:material, node, %Robot.Visual{} = visual) do
    with {:ok, name} <- get_attribute_value(node, :name),
         material <- Robot.Material.init(name),
         {:ok, children} <- get_children(node),
         {:ok, material} <- reduce_oks(children, material, &parse(&1, &2)),
         visual <- Robot.Visual.material(visual, material),
         do: {:ok, visual}
  end

  defp parse(:origin, node, orientable) do
    [roll, pitch, yaw] =
      node
      |> extract_floats(:rpy, [0, 0, 0])
      |> Enum.map(&Angle.Radian.init(&1))

    [x, y, z] = extract_floats(node, :xyz, [0, 0, 0])

    orientation = Orientations.Euler.init(:xyz, roll, pitch, yaw)
    translation = Coordinates.Cartesian.init(x, y, z)
    frame = Frame.init(translation, orientation)

    {:ok, Robot.Orientable.set(orientable, frame)}
  end

  defp parse(:mesh, node, geometric) do
    with {:ok, filename} <- get_attribute_value(node, :filename),
         [scale] <- extract_floats(node, :scale, [1.0]),
         mesh <- Geometry.Mesh.init(filename),
         mesh <- Geometry.Mesh.scale(mesh, scale),
         do: {:ok, Robot.Geometric.set(geometric, mesh)}
  end

  defp parse(:axis, node, %Robot.Joint{} = joint) do
    [x, y, z] = extract_floats(node, :xyz, [0, 0, 0])

    translation = Coordinates.Cartesian.init(x, y, z)
    {:ok, Robot.Joint.axis(joint, translation)}
  end

  defp parse(:limit, node, %Robot.Joint{} = joint) do
    [effort] = extract_floats(node, :effort, [0])
    [lower] = extract_floats(node, :lower, [0])
    [upper] = extract_floats(node, :upper, [0])
    [velocity] = extract_floats(node, :velocity, [0])

    limit = Robot.Limit.init(effort: effort, lower: lower, upper: upper, velocity: velocity)
    {:ok, Robot.Joint.limit(joint, limit)}
  end

  defp parse(:calibration, node, %Robot.Joint{} = joint) do
    [rising] = extract_floats(node, :rising, [nil])
    [falling] = extract_floats(node, :falling, [nil])

    calibration = Robot.Calibration.init(rising, falling)
    {:ok, Robot.Joint.calibration(joint, calibration)}
  end

  defp parse(:dynamics, node, %Robot.Joint{} = joint) do
    [damping] = extract_floats(node, :damping, [0])
    [friction] = extract_floats(node, :friction, [0])

    dynamics = Robot.Dynamics.init(damping, friction)
    {:ok, Robot.Joint.dynamics(joint, dynamics)}
  end

  defp parse(:mimic, node, %Robot.Joint{} = joint) do
    [multiplier] = extract_floats(node, :multiplier, [1])
    [offset] = extract_floats(node, :offset, [0])

    with {:ok, name} <- get_attribute_value(node, :joint),
         mimic <- Robot.Mimic.init(name, multiplier, offset),
         do: {:ok, Robot.Joint.mimic(joint, mimic)}
  end

  defp parse(:safety_controller, node, %Robot.Joint{} = joint) do
    [soft_lower_limit] = extract_floats(node, :soft_lower_limit, [0])
    [soft_upper_limit] = extract_floats(node, :soft_upper_limit, [0])
    [k_position] = extract_floats(node, :k_position, [0])
    [k_velocity] = extract_floats(node, :k_velocity, [0])

    safety_controller =
      Robot.SafetyController.init(k_velocity, k_position, soft_lower_limit, soft_upper_limit)

    {:ok, Robot.Joint.safety_controller(joint, safety_controller)}
  end

  defp parse(:collision, node, %Robot.Link{} = link) do
    collision =
      case get_attribute_value(node, :name) do
        {:ok, name} -> Robot.Collision.init(name)
        _ -> Robot.Collision.init()
      end

    with {:ok, children} <- get_children(node),
         {:ok, collision} <- reduce_oks(children, collision, &parse(&1, &2)),
         do: {:ok, Robot.Link.collision(link, collision)}
  end

  defp parse(:inertial, node, %Robot.Link{} = link) do
    with inertia <- Robot.Inertia.init(),
         {:ok, children} <- get_children(node),
         {:ok, inertia} <- reduce_oks(children, inertia, &parse(&1, &2)),
         do: {:ok, Robot.Link.inertia(link, inertia)}
  end

  defp parse(:mass, node, %Robot.Inertia{} = inertia) do
    [mass] = extract_floats(node, :value, [0])
    {:ok, Robot.Inertia.mass(inertia, mass)}
  end

  defp parse(:inertia, node, %Robot.Inertia{} = inertia) do
    [ixx] = extract_floats(node, :ixx, [0])
    [ixy] = extract_floats(node, :ixy, [0])
    [ixz] = extract_floats(node, :ixz, [0])
    [iyy] = extract_floats(node, :iyy, [0])
    [iyz] = extract_floats(node, :iyz, [0])
    [izz] = extract_floats(node, :izz, [0])

    matrix = Orientations.RotationMatrix.init({ixx, ixy, ixz, ixy, iyy, iyz, ixz, iyz, izz})
    {:ok, Robot.Inertia.matrix(inertia, matrix)}
  end

  defp parse(:transmission, node, %Robot{} = robot) do
    with {:ok, name} <- get_attribute_value(node, :name),
         transmission <- Robot.Transmission.init(name),
         {:ok, children} <- get_children(node),
         {:ok, transmission} <- reduce_oks(children, transmission, &parse(&1, &2)),
         robot <- Robot.add_transmission(robot, transmission),
         do: {:ok, robot}
  end

  defp parse(:type, node, %Robot.Transmission{} = transmission) do
    with {:ok, contents} <- get_text(node),
         do: {:ok, Robot.Transmission.type(transmission, String.trim(contents))}
  end

  defp parse(:joint, node, %Robot.Transmission{joints: joints} = transmission) do
    with {:ok, name} <- get_attribute_value(node, :name),
         joint <- Robot.TransmissionJoint.init(name),
         {:ok, children} <- get_children(node),
         {:ok, joint} <- reduce_oks(children, joint, &parse(&1, &2)),
         transmission <- Robot.Transmission.joints(transmission, [joint | joints]),
         do: {:ok, transmission}
  end

  defp parse(
         :hardwareInterface,
         node,
         %Robot.TransmissionJoint{hardware_interfaces: hardware_interfaces} = joint
       ) do
    with {:ok, contents} <- get_text(node),
         hardware_interface <- Robot.HardwareInterface.init(contents),
         joint <-
           Robot.TransmissionJoint.hardware_interfaces(joint, [
             hardware_interface | hardware_interfaces
           ]),
         do: {:ok, joint}
  end

  defp parse(
         :hardwareInterface,
         node,
         %Robot.Actuator{hardware_interfaces: hardware_interfaces} = actuator
       ) do
    with {:ok, contents} <- get_text(node),
         hardware_interface <- Robot.HardwareInterface.init(contents),
         actuator <-
           Robot.Actuator.hardware_interfaces(actuator, [
             hardware_interface | hardware_interfaces
           ]),
         do: {:ok, actuator}
  end

  defp parse(:actuator, node, %Robot.Transmission{actuators: actuators} = transmission) do
    with {:ok, name} <- get_attribute_value(node, :name),
         actuator <- Robot.Actuator.init(name),
         {:ok, children} <- get_children(node),
         {:ok, actuator} <- reduce_oks(children, actuator, &parse(&1, &2)),
         transmission <- Robot.Transmission.actuators(transmission, [actuator | actuators]),
         do: {:ok, transmission}
  end

  defp parse(:mechanicalReduction, node, %Robot.Actuator{} = actuator) do
    with {:ok, contents} <- get_text(node),
         {value, _} <- Float.parse(String.trim(contents)),
         actuator <- Robot.Actuator.mechanical_reduction(actuator, value),
         do: {:ok, actuator}
  end

  defp parse(:texture, node, %Robot.Material{} = material) do
    with {:ok, filename} <- get_attribute_value(node, :filename),
         texture <- Robot.Texture.init(filename),
         material <- Robot.Material.texture(material, texture),
         do: {:ok, material}
  end

  defp parse(:gazebo, _node, %Robot{name: name} = robot) do
    Logger.warn("Ignoring gazebo element in robot #{inspect(name)}")
    {:ok, robot}
  end

  defp extract_floats(node, attribute_name, default_value) do
    with {:ok, string} <- get_attribute_value(node, attribute_name),
         string_values <- String.split(string, ~r/\s+/),
         float_values <-
           string_values
           |> Enum.filter(&(byte_size(&1) > 0))
           |> Enum.map(&elem(Float.parse(&1), 0)) do
      float_values
    else
      _ -> default_value
    end
  end
end
